# JVM. Организация памяти, сборщики мусора, VisualVM

## Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM.

***
***Не забудьте упомянуть про:***

* ***ClassLoader’ы***
* ***Области памяти (стэк (и его фреймы), heap)***
* ***Сборщик мусора***
***

### Код для исследования:

```java
public class JvmComprehension {
    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }
    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}
```
#### В момент вызова класса `main`:
- В стеке выделяется блок памяти **Frame**.
1. В стек помещается переменная **i** и её значение **1**.
2. В стек помещается ссылка на объект **o**, а в кучу **Heap** помещается сам объект.
3. В стек помещается ссылка на объект **ii**, а в кучу **Heap** помещается значение переменной.
4. При вызове метода **printAll()** выделяется блок памяти **Frame**.
5. В стек помещается ссылка на объект **uselessVar**, а в кучу **Heap** помещается значение.
6. В куче **Heap** создается объект **String**, в стек помещается ссылка на **String** и вызывается метод **System.out.println**. После вызова метода **println** работа метода **printAll** завершится и фрейм стека будет удалён для этого метода.
7. В кучу **Heap** создается объект **String**, в стек помещается ссылка на **String** и вызывается метод **System.out.println("finished")**. После вызова метода **println** работа метода **main** завершится и фрейм стека будет удалён для этого метода.